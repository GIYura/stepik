#### Общая информация

Имеется:
- клиент;
- сервер;
- два именованных канала для отправки и приема сообщений.

При попытке чтения из канала при отсутсвии там данных (т.е)
файловый дискриптор находится в ссотянии НЕ ГОТОВ.
При этом приложение блокируется и ждет до тех пор пока в 
канале не появятся данные. Такая блокировка не позволяет
работать с несколькими каналами.

         client-to-server         
|CLIENT| ---------------------> |SERVER|
         server-to-client
       <--------------------

Предположим на стороне Сервера есть несколько открытых файлов:
- файл 0 - stdin;
- файл 1 - stdout;
- файл 2 - stderr;
- f1, f2, f3 - файловые дискрипторы созданный пользователем;

int f1 = open(...);

Для работы с несколькими файловыми дискрипторами необхожимо создать
контейнер наблюдения. Это по сути набор битовых флагов, каждый бит
соответсвует номеру файлового дискриптора. Тип такого контейнера 
```
fd_set.
```
Пример:
```
fd_set watchList; /* 1 - соответствует дискриптору за которым 
мы хотим наблюдать; 0 - дискриптор нас не ритересует */
```
В Linux есть ряд макровос для работы с этими битовыми флагами:
```
- FD_ZERO(&watchList) - обнулить все (убрать все файлы из списка наблюдения);
- FD_SET(f1, &watchList) - наблюдать за f1;
- FD_CLR(f1, &watchList) - исключить f1 из наблюдения
```
Для наблюдения за файлами применяют функцию select.

Пример:
```
- int select(f3+1, fd_set_read, fd_set_write, fd_set_except, time_wait);
```
Проверка установлен ли файловый дискриптор в список наблюдения:
```
FD_ISSET(f1, &watchList);
```

