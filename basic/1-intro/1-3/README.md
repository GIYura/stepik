#### Runtime линковка. Libdl

Во всех рассмотренных ранее случаях и при компоновке программы, как со статической, так и с динамической библиотекой, эти библиотеки уже 
должны быть на компьютере. И связывание исполнимого файла с ними достаточно жесткое.

В ряде случаев бывает необходимо подключать внешние динамические библиотеки не на этапе сборки приложения, а уже при его выполнении. 
Например, таким образом к программе могут подключаться разнообразные расширения "плагины", которых на момент сборки программы ещё может 
не существовать в природе.

Для загрузки динамических библиотек и вызова, расположенных там функций, непосредственно в процессе исполнения программы служит специальный 
системный интерфейс **libdl**. Это набор функций в системной динамической библиотеке при помощи которых можно загрузить произвольную библиотеку 
в память, просмотреть какие символы (в том числе функции) есть в этой библиотеке, а затем вызвать их исполнение.

Рассмотрим простейший пример применения интерфейса **libdl** для загрузки нашей библиотеки libHello.so. Файл main.c

```
#include <stddef.h>
#include <stdbool.h>
#include <stdio.h>
#include <dlfcn.h>

void (*hello_message)(const char *);

bool init_library()
{
    void *hdl = dlopen("./libHello.so", RTLD_LAZY);
    if(NULL == hdl)
        return false;

    hello_message = (void(*)(const char *))dlsym(hdl, "hello_message");
    if(NULL == hello_message)
        return false;

    return true;
}

int main()
{
    if(init_library())
        hello_message("Vasya");
    else
        printf("Library was not loaded\n");
    return 0;
}
```

Начнём с подключаемых заголовочных файлов:

- stdbool.h нужен для получения значения констант true и false;
- stdio.h для использования функции printf();
- stddef.h даёт определение нулевого указателя NULL;
- dlfcn.h описаны функции dlopen() и dlsym().

Добавим к нашей программе указатель на функцию **hello_message()**, а затем напишем функцию **init_library()** которая будет загружать 
библиотеку и инициализировать этот указатель.

Функция **dlopen()** нужна чтобы загрузить библиотеку в память. Ей мы передаём имя библиотеки (вместе с путем).
Второй параметр может принимать значения **RTLD_NOW** (библиотека будет загружена в память непосредственно в момент вызова функции dlopen()) 
или **RTLD_LAZY** (библиотека будет загружена только тогда, когда программа попытается обратиться к её содержимому).

Далее, используя указатель **hdl**, который возвращает функция **dlopen()** мы вызываем функцию **dlsym()** которая находит в загруженной 
библиотеке и возвращает нам указатель на требуемую функцию **hello_message()**. Оба раза мы проверяем, что вызовы системных функций 
завершились успешно, сравнивая результат, который они возвращают с **NULL**.

Функция **dlsym()** возвращает void * то есть не типизированный указатель который мы должны сами привести к указателю на функцию прототип 
которой нам должен быть известен.

Наконец в функции main() производится проверка, что загрузка библиотеки прошла успешно и вызывается функция **hello_message()**. 
Если же библиотеку загрузить не удалось или в ней отсутствует символ (функция) **hello_message**, то программа выдаёт сообщение об ошибке.

Также требуется небольшая модификация **Makefile**, так как наша программа более напрямую не зависит от библиотеки libHello.so, 
но зато ей требуется библиотека **libdl**

```
all: exe lib

exe: main.c
	gcc main.c -fPIC -ldl -o hello

lib: hello.c hello.h
	gcc -shared hello.c -fPIC -o libHello.so

clean:
	-rm hello libHello.so 2>/dev/null
```

Если после сборки приложения запустить команду ldd hello, то можно убедиться, что наше приложение более формально не зависит от библиотеки 
libHello.so.

Более подробно с данной темой можно ознакомиться в статье "Анатомия динамических библиотек Linux".

